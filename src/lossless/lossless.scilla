scilla_version 0

import BoolUtils IntUtils

library LosslessLottery

let zero: Uint128 = Uint128 0
let one: Uint128 = Uint128 1
let ten: Uint128 = Uint128 10
let successful_deposit_code: Int32 = Int32 -1
let insufficient_balance_code: Int32 = Int32 -2
let user_not_present_code: Int32 = Int32 -3
let fund_withdraw_success_code: Int32 = Int32 -4
let staking_contract_adress_update: Int32 = Int32 -5
let not_owner_code: Int32 = Int32 -6

let get_user_amount = 
    fun (bs : Map ByStr20 Uint128) =>
    fun (sender : ByStr20) =>
        builtin get bs sender

let one_msg = fun(msg: Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
    fun (msg1 : Message) =>
    fun (msg2 : Message) =>
        let msgs_tmp = one_msg msg2 in
        Cons {Message} msg1 msgs_tmp

contract LosslessLottery(owner: ByStr20, 
                         owner_percent: Uint128)

field backers : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field staking_contract: ByStr20 = 0x62a9d5d611cdcae8d78005f31635898330e06b93
field staking_contract_stake_transition: String = "DelegateStake"

transition update_staking_contract(staking_contract_address: ByStr20, staking_contract_delegate_transition: String)
    is_owner = builtin eq _sender owner;
    match is_owner with
    | True =>
        staking_contract := staking_contract_address;
        staking_contract_stake_transition := staking_contract_delegate_transition;
        e = {
            _eventname: "Staking contract address updated";
            code: staking_contract_adress_update
        };
        event e
    | False =>
      e = {
            _eventname: "Staking contract address updated";
            code: not_owner_code
        };
      event e
    end
end

transition PoolIn()
    bs <- backers;
    user_balance = get_user_amount bs _sender;
    accept;
    match user_balance with
    | None =>
        backers[_sender] := _amount;
        msg = { _tag: "Funds Added";
                _recipient: _sender;
                _amount: zero;
                code: successful_deposit_code
            };
        msgs = one_msg msg;
        e = {
            _eventname: "Funds Added";
            user: _sender;
            amount: _amount;
            code: successful_deposit_code
            };
        
        send msgs;
        event e

    | Some sender_amt =>
        new_sender_amt = builtin add sender_amt _amount;
        backers[_sender] := new_sender_amt;
        msg = { _tag: "Funds Added";
                _recipient: _sender;
                _amount: zero;
                code: successful_deposit_code
            };
        msgs = one_msg msg;
        e = {
            _eventname: "Funds Added";
            user: _sender;
            amount: _amount;
            code: successful_deposit_code
            };
        
        send msgs;
        event e
    end
end

transition PoolOut(amount: Uint128)
    bs <- backers;
    user_balance = get_user_amount bs _sender;

    match user_balance with
    | None =>
        user_not_present_error ={
                                _eventname: "User Not Present";
                                user: _sender;
                                code: user_not_present_code
                                };
        event user_not_present_error
    | Some user_balance_value =>
        balance_diff = builtin sub user_balance_value amount;
        check_sufficient_balance = builtin lt balance_diff zero;
        match check_sufficient_balance with
        | True =>
            insufficient_balance_error ={
                                        _eventname: "Insufficient Balance";
                                        user: _sender;
                                        code: insufficient_balance_code
                                        };
            event insufficient_balance_error
        | False =>
            backers[_sender] := balance_diff;
            msg = {
                    _tag: "Funds Withdrawn";
                    _recipient: _sender;
                    _amount: amount;
                    code: fund_withdraw_success_code
            };
            msgs = one_msg msg;
            send msgs
        end
    end
end

transition stake_zil(ssn_addr: ByStr20)
  staking_contract_address <- staking_contract;
  msg = {
      _recipient: staking_contract_address;
      _amount: one;
      _tag: "DelegateStake";
      ssn_addr: ssn_addr
  };
  msgs = one_msg msg;
  send msgs
end

transition draw_winner(random_seed: Uint128, )
